<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="box">btn</div>
    <script>
        //纯函数
        // let arr = [1, 2, 3, 4, 5]
        // let res = arr.slice(0, 3)
        // console.log(arr)
        // console.log(res.slice(0, 3))
        //函数式编程
        // function changes(age) {
        //     return age > 18
        // }
        // var checkage = min => (age => age > min);

        // function chenge(min) {
        //     return function (age) {
        //         return age > min
        //     }
        // }
        // console.log(checkage(3)(4))

        // let checkage = min => (age => age > min);
        // console.log(checkage(20)(21))
        // console.log(changes(23))


        //纯函数让变量更灵活
        // let res = (f, g) => (x => f(g(x)));
        // var s = res((g) => {
        //     box.innerHTML = g
        //     return true
        // }, (x) => {

        //     let span = x.map(item => `<span>${item}</span>`);
        //     return span.join("")
        // })([1, 2, 3, 4])
        // if (s) {
        //     var spans = document.querySelectorAll("span");
        //     console.log(spans)
        // }


        // let res = function (f, g) {
        //     return function (x) {
        //         return f(g(x))
        //     }
        // }
        // console.log(res(function (x) {
        //     console.log(x)
        //     return "f" + x
        // }, function (x) {
        //     console.log(x)
        //     return "g" + x
        // })(3))

        //高阶函数
        // var add = (arr) => (arr.map(item => `<div>${item}</div>`));

        // function m(fun, ...arr) {
        //     return fun(arr)
        // }
        // const a = m(add, 1, 2, 3, 4, 5, 6)
        // console.log(a)

        //尾调用
        // function add(n, t) {
        //     if (n == 0) return t;
        //     console.log("t==>", t)
        //     console.log("n-1==>", n - 1)
        //     console.log("n+t==>", n * t)
        //     return add(n - 1, n * t)
        // }
        // console.log(add(5, 1))

        //闭包

        // function add(a) {
        //     var s = 5;
        //     return function (b) {
        //         var d = s + a + b
        //         return d
        //     }
        // }
        // console.log(add(4)(3));

        // function add(n) {
        //     if (n == 1) return n
        //     var d = add(n - 1)//4//3//2//1
        //     var s = n + d
        //     console.log("s===" + s) //3==>6=>10=>15
        //     console.log("d===" + d) //1==>3=>6=>10
        //     console.log("n===" + n) //2==>3=>4=>5
        //     return s
        // }
        // console.log(add(5))
        //容器、函子
        function Co(val) {
            this._val = val
        }
        //函数式编程一般约定，函子有一个of方法
        Co.of = function (x) {
            return new Co(x);
        }
        //一般约定，函子的标志就是容器具有map方法。该方法将容器里的每一个值，映射到另一个容器里
        Co.prototype.map = function (f) {
            return Co.of(f(this._val))
        }
        var s = Co.of(4).map(x => x + x).map(x => "结果是" + x)
        console.log(s._val)

        //
    </script>
</body>

</html>